#+TITLE:  Dragon Script
#+AUTHOR: Comcx
#+DATE:   <2019-04-09 äºŒ>

:IDEA:

 Well I suddenly contrived the idea that I should find some basic(atom)
 problems which can be used or composed in various kinds of problems,
 which can save some time.
 
 Therefore, I'm planning to reconstruct the structure of this script.
 not only just records of my solutions of katas, but all simple ideas
 novelty :)

:END:


* Weapons

** Books
*** Concrete Mathematics
*** CLRS

* Dragons [11/13]

** DONE Longest Substring Without Repeating Characters                 :EASY:

*** Description

Given a string, find the length of the longest substring without repeating characters.
#+BEGIN_SRC
Example 1:
Input: "abcabcbb"
Output: 3 
Explanation: The answer is "abc", with the length of 3. 

Example 2:
Input: "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.

Example 3:
Input: "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3. 
Note that the answer must be a substring, "pwke" is a subsequence and not a substring.
#+END_SRC

*** Analysis
  Let's generalize this problem a little bit:

**** Settings
   - Say our indices in the array comes from 0.
   - Our solver 
       =f : Seq a ==> Index -> (List a -> a -> Bool) -> (List a, Length)=
       which gives the answer on the range index of [0, n]
**** Environment
   s : List a
**** Pseudocode
#+BEGIN_SRC haskell
f 0 p = if p [] (s 0) then ([s 0], 1) else ([], 0)
f n p = if p a (s n) then (a ++ [s n], len + 1) else ([s n], 0)
where
  (a, len) = f (n - 1) p

-- Here we can make
p a x = not $ elem a x

main = f (length s - 1) p
#+END_SRC

Ok, we can see now we must tranverse the entire array, which is O(n),
therefore, the complexity is depend on the complexity of function *p*.

I we use hash, we can have function p with time complexity O(1)
and finally we have O(n) algorithm.

If we do not use hash, any better way?

*** Solution

#+BEGIN_SRC c++
//O(nlgn)?? or better?
//Failed to find a better way to check if current elem already existed
//use array[256]:(

//I tried several several times on Leet but failed:(! Switching back to CodeWars
class Solution {
public:

int lengthOfLongestSubstring(string s) {
        
  int ans = 1;
  int acc[256];
  int p = 0;
  
  memset(acc, 0, 256);
  for(int i = 0; i < s.size(); ++i) {
    
    if(acc[s[i]] == 1) {

      while(s[p] != s[i]) {
      
        acc[s[p]] = 0;
    	++p;
      }
      p += 1;
      ans = (ans < i-p+1) ? i-p+1 : ans;
    }
    else ans = (ans < i-p+1) ? i-p+1 : ans;
    acc[s[i]] = 1;
  }
  return ans;
}

};



#+END_SRC

** DONE Find The Parity Outlier                                        :EASY:

*** Description
You are given an array (which will have a length of at least 3, 
but could be very large) containing integers. 
The array is either entirely comprised of odd integers or 
entirely comprised of even integers except for a single integer N. 
Write a method that takes the array as an argument and returns this "outlier" N.
#+BEGIN_SRC 

Examples
[2, 4, 0, 100, 4, 11, 2602, 36]
Should return: 11 (the only odd number)

[160, 3, 1719, 19, 11, 13, -21]
Should return: 160 (the only even number)
#+END_SRC

*** Solution

#+BEGIN_SRC C++
int FindOutlier(std::vector<int> arr)
{
    int even;
    int odd;
  
    int evenCount = 0;
    int oddCount = 0;
  
    for (auto a : arr)
        a % 2 == 0 ? (evenCount++, even = a) : (oddCount++, odd = a);
  
    return evenCount < oddCount ? even : odd;
}


#+END_SRC

** NEXT Cycle detection                                                :MEDI:

*** Extant
*** Floyd algorithm

*** Bernt's algorithm(The Teleporting Turtle)

*** Experiment

** DONE Factorial decomposition                                        :MEDI:

*** Description
The aim of the kata is to decompose n! (factorial n) into its prime factors.
#+BEGIN_SRC 
Examples:

n = 12; decomp(12) -> "2^10 * 3^5 * 5^2 * 7 * 11"
since 12! is divisible by 2 ten times, by 3 five times, by 5 two times and by 7 and 11 only once.

n = 22; decomp(22) -> "2^19 * 3^9 * 5^4 * 7^3 * 11^2 * 13 * 17 * 19"

n = 25; decomp(25) -> 2^22 * 3^10 * 5^6 * 7^3 * 11^2 * 13 * 17 * 19 * 23
Prime numbers should be in increasing order. When the exponent of a prime is 1 don't put the exponent.

#+END_SRC
*Notes*

- the function is decomp(n) and should return the decomposition of n! into 
  its prime factors in increasing order of the primes, as a string.
- factorial can be a very big number (4000! has 12674 digits, n will go from 300 to 4000).

*** Solution
#+BEGIN_SRC c++
#include <string>
#include <map>
#include <sstream>

using std::vector;
using std::string;
using std::map;
string decomp(int n) {
  
  string ans("");
  std::stringstream ss;
  map<int, int> rc {};
  for(int i(2); i <= n; ++i) {
    
    int cur(i);
    for(auto &p : rc) {
      while(cur % p.first == 0) {
        cur /= p.first;
        p.second++;
      }
    }
    if(cur > 1) rc[cur] = 1;
  }
  for(auto p : rc) {
    
    (p.second == 1) ?
      ss << p.first : 
      ss << p.first << "^" << p.second;
    ss << " * ";
  }
  ans = ss.str();
  
  return ans.substr(0, ans.length() - 3);
}
#+END_SRC

** DONE Counting Change Combinations                                   :MEDI:

*** Description
Write a function that counts how many different ways you can make change for an amount of money, 
given an array of coin denominations. 
For example, there are 3 ways to give change for 4 if you have coins with denomination 1 and 2:
=1+1+1+1, 1+1+2, 2+2.=

The order of coins does not matter:
=1+1+2 == 2+1+1=

Also, assume that you have an infinite amount of coins.

Your function should take an amount to change and an array of unique denominations for the coins:

#+BEGIN_SRC c++
count_change(4,  {1,2})   // => 3
count_change(10, {5,2,3}) // => 4
count_change(11, {5,7})   // => 0
#+END_SRC

*** Analysis

#+BEGIN_SRC haskell

-- m := money
-- i := index of coins
count m i = count (m - (coins i)) i + count m (i + 1)
count 0 _ = 1
#+END_SRC
found a bug here, you can't export to html if u have codes on the 1st line of haskell code block
**** Complexity
   underwork

*** Solution

#+BEGIN_SRC c++

#include <vector>
#include <algorithm>

using std::vector;
using large = unsigned long long;
large
dp(unsigned money, const vector<unsigned int>& coins) {

  large ans(0);
  large **rc = new large*[money + 1];
  for (int i = 0; i < money+1; ++i) rc[i] = new large[coins.size()];
  
  for(int i(0); i <= money; ++i)
    rc[i][coins.size()-1] = i % coins[coins.size()-1] == 0 ? 1 : 0;
  for(int j(0); j < coins.size(); ++j)
    rc[0][j] = 1;
  
  for(int i(1); i <= money; ++i)
    for(int j(coins.size()-2); j >= 0; --j) {
      
      if(i >= coins[j]) {
        rc[i][j] = rc[i - coins[j]][j]
                 + rc[i][j + 1];
      }
      else rc[i][j] = 0;
    }
  
  return rc[money][0];
}
//count m i = count (m-coins[i]) i + count m (i+1)
//count 0 _ = 1

large 
countChange(const unsigned int money, const vector<unsigned int>& coins) {

  large ans(0);
  
  vector<unsigned int> pac(coins);
  std::sort(pac.begin(), pac.end());

  ans = dp(money, pac);
  
  return ans;
}

#+END_SRC

#+BEGIN_SRC c++
using large = unsigned long long;
large 
countChange(unsigned money, const std::vector<unsigned>& coins) {
  std::vector<large> ks(money + 1);
  ks[0] = 1;
  for (unsigned i : coins)
    for (unsigned j = i; j <= money; j++)
      ks[j] += ks[j - i];
  return ks[money];
}
#+END_SRC
Somehow a little confused with this solution)

** DONE ZigZag Conversion                                              :MEDI:

*** Description
The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)
#+BEGIN_SRC
P   A   H   N
A P L S I I G
Y   I   R
#+END_SRC
And then read line by line: "PAHNAPLSIIGYIR"

Write the code that will take a string and make this conversion given a number of rows:

string convert(string s, int numRows);

Example 1:
#+BEGIN_SRC
Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"
#+END_SRC

Example 2:
#+BEGIN_SRC
Input: s = "PAYPALISHIRING", numRows = 4
Output: "PINALSIGYAHRPI"

Explanation:

P     I    N
A   L S  I G
Y A   H R
P     I
#+END_SRC

*** Solution

#+BEGIN_SRC c++

string Solution::convert(string s, int numRows) {
  
  string ans("");
  int cur(0);
  if(numRows == 1) return s;
  for(int i(1); i <= numRows; ++i) {
    
    int j(cur), invert(numRows - i);
    ans += string(1, s[cur]);
    while((cur = cur + invert * 2) < s.size()) {
      
      ans += invert ? string(1, s[cur]) : "";
      invert = (numRows - invert - 1);
      if(cur + invert * 2 < s.size()) {
        ans += invert ? 
          (cur += invert * 2, string(1, s[cur])) : "";
      } else break;
      invert = (numRows - invert - 1);
    }
    cur = i;
  }
  
  return ans;
}

#+END_SRC

** DONE Longest Palindromic Substring                             :HARD:BOND:

*** Description
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example 1:
#+BEGIN_SRC
Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
#+END_SRC

Example 2:
#+BEGIN_SRC
Input: "cbbd"
Output: "bb"
#+END_SRC

*** Analysis

Let's first find the way to get the longest length
#+BEGIN_SRC haskell

-- s := the string(data)
-- i := left index
-- j := right index
f i j | i == j     = 1
      | j - i == 2 = if s[i] == s[j] then 2 else 0
      | otherwise  = if s[i] == s[j] && inner then inner + 2 else 0
where inner = f (i + 1) (j - 1)
#+END_SRC

*** Solution

**** Dynamic Programming
#+BEGIN_SRC c++

//DP method
string longestPalindrome(string s) {
  
  int rc[1000][1000], start(0), end(0), cur(0);
  for(int i(s.size()-1); i >= 0; --i) {
    for(int j(i); j < s.size(); ++j) {
      
      if(i == j) rc[i][j] = 1;
      else if(j - i == 1) rc[i][j] = s[i] == s[j] ? 2 : 0;
      else rc[i][j] = 
        rc[i+1][j-1] && s[i] == s[j] ? rc[i+1][j-1] + 2 : 0;
      cur = rc[i][j] > cur ?
        start = i, end = j, rc[i][j] : cur;
    }
  }
  return s.substr(start, end-start+1);
}

#+END_SRC
- Summary
  Focus on how answer is constructed by answers.
  Unfortunately, still O(n^2)

**** Manacher's Algorithm
underwork

** DONE Maximum Subarray                                          :MEDI:BOND:

*** Description
Given an integer array nums, 
find the contiguous subarray (containing at least one number) 
which has the largest sum and return its sum.

Example:
#+BEGIN_SRC
Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
Follow up:
#+END_SRC
If you have figured out the O(n) solution, 
try coding another solution using the divide and conquer approach, 
which is more subtle.

*** Solution
#+BEGIN_SRC C++

int Solution::maxSubArray(vector<int>& nums) {
  
  int ans(INT_MIN), sum(0);
  for (int n : nums)
    sum = max(sum + n, n),
    ans = max(ans, sum);
  
  return ans;
}

#+END_SRC

** DONE Climbing Stairs                                                :EASY:

*** Description
You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Note: Given n will be a positive integer.

Example 1:
#+BEGIN_SRC
Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
#+END_SRC
Example 2:
#+BEGIN_SRC
Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
#+END_SRC

*** Analysis

#+BEGIN_SRC haskell

f 0 = 1
f n = if n < 0 then 0 else f (n-1) + f (n-2)
#+END_SRC
Obviously, it's a fibonacci seq!

*** Solution
#+BEGIN_SRC c++

int Solution::climbStairs(int n) {
  
  int a(0), b(1), x(0);
  for(int i(2); i <= n; ++i)
    x = a + b,
    a = b, b = x;
  
  return a + b;
}

#+END_SRC

** DONE Regular Expression Matching                                    :HARD:

*** Description
Given an input string (s) and a pattern (p), 
implement regular expression matching with support for '.' and '*'.

- '.' Matches any single character.
- '*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).

Note:

- s could be empty and contains only lowercase letters a-z.
- p could be empty and contains only lowercase letters a-z, and characters like . or *.
Example 1:
#+BEGIN_SRC
Input:
s = "aa"
p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
#+END_SRC
Example 2:
#+BEGIN_SRC
Input:
s = "aa"
p = "a*"
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".
#+END_SRC
Example 3:
#+BEGIN_SRC
Input:
s = "ab"
p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".
#+END_SRC
Example 4:
#+BEGIN_SRC
Input:
s = "aab"
p = "c*a*b"
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches "aab".
#+END_SRC
Example 5:
#+BEGIN_SRC
Input:
s = "mississippi"
p = "mis*is*p*."
Output: false
#+END_SRC

*** Solution
#+BEGIN_SRC c++
bool Solution::isMatch(string s, string p) {
  
  return
    p == "" ? s == "" :
    p.size() > 1 && p[1] == '*' ?
      isMatch(s, p.substr(2)) || 
        (s != "" && (s[0] == p[0] || p[0] == '.') && isMatch(s.substr(1), p)) :
    s != "" && 
      (s[0] == p[0] || p[0] == '.') && isMatch(s.substr(1), p.substr(1));
}

#+END_SRC

** DONE Wildcard Matching                                              :MEDI:

*** Description
Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.
#+BEGIN_SRC
'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like ? or *.
Example 1:

Input:
s = "aa"
p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
Example 2:

Input:
s = "aa"
p = "*"
Output: true
Explanation: '*' matches any sequence.
Example 3:

Input:
s = "cb"
p = "?a"
Output: false
Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.
Example 4:

Input:
s = "adceb"
p = "*a*b"
Output: true
Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring "dce".
Example 5:

Input:
s = "acdcb"
p = "a*c?b"
Output: false
#+END_SRC

*** Solution
#+BEGIN_SRC C++
class Solution {
public:
  bool isMatch(string s, string p);
};

bool Solution::isMatch(string s, string p) {
  
  int m(s.size()), n(p.size());
  bool rc[m+1][n+1];
  
  for(int i(m); i >= 0; --i)
    for(int j(n); j >= 0; --j)
      
      rc[i][j] = 
        i == m && j == n      ? true                     :
        i == m && p[j] == '*' ? rc[i][j+1]               :
        i == m || j == n      ? false                    :
        p[j] == '.'           ? rc[i+1][j+1]             :
        p[j] == '*'           ? rc[i+1][j] || rc[i][j+1] :
        p[j] == s[i]          ? rc[i+1][j+1]             :
        /*otherwise          */ false                    ;
  
  return rc[0][0];
}

#+END_SRC

** TODO The Josephus Problem
