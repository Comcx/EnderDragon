#+TITLE:  Dragon Script
#+AUTHOR: Comcx
#+DATE:   <2019-04-09 äºŒ>

:IDEA:

 Well I suddenly contrived the idea that I should find some basic(atom)
 problems which can be used or composed in various kinds of problems,
 which can save some time.
 
 Therefore, I'm planning to reconstruct the structure of this script.
 not only just records of my solutions of katas, but all simple ideas
 novelty :)

:END:


* Add Two Numbers


** Description

You are given two non-empty linked lists representing two non-negative integers. 
The digits are stored in reverse order and each of their nodes contain a single digit. 
Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.
#+BEGIN_SRC
Example:

Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.
#+END_SRC

** Solution

#+BEGIN_SRC C++

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
      
      ListNode *a = l1, 
               *b = l2;
      ListNode ans = ListNode(-1),
               *cur = &ans;
      int cre = 0;
      do {
        
        int sum = (a ? a->val : 0) + (b ? b->val : 0) + cre;
        int bit = sum % 10;
        cre = sum / 10;
        
        cur->next = new ListNode(bit);
        
        cur = cur->next;
        a = a ? a->next : NULL;
        b = b ? b->next : NULL;
        
      } while(a || b);
      
      if(cre == 1) cur->next = new ListNode(1);
      return ans.next;
    }
};


#+END_SRC



* Longest Substring Without Repeating Characters

** Description

Given a string, find the length of the longest substring without repeating characters.
#+BEGIN_SRC
Example 1:
Input: "abcabcbb"
Output: 3 
Explanation: The answer is "abc", with the length of 3. 

Example 2:
Input: "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.

Example 3:
Input: "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3. 
Note that the answer must be a substring, "pwke" is a subsequence and not a substring.
#+END_SRC

** Solution

#+BEGIN_SRC c++
//O(nlgn)?? or better?
//Failed to find a better way to check if current elem already existed
//use array[256]:(

//I tried several several times on Leet but failed:(! Switching back to CodeWars
class Solution {
public:

int lengthOfLongestSubstring(string s) {
        
  int ans = 1;
  int acc[256];
  int p = 0;
  
  memset(acc, 0, 256);
  for(int i = 0; i < s.size(); ++i) {
    
    if(acc[s[i]] == 1) {

      while(s[p] != s[i]) {
      
        acc[s[p]] = 0;
    	++p;
      }
      p += 1;
      ans = (ans < i-p+1) ? i-p+1 : ans;
    }
    else ans = (ans < i-p+1) ? i-p+1 : ans;
    acc[s[i]] = 1;
  }
  return ans;
}

};



#+END_SRC


* Find The Parity Outlier

** Description
You are given an array (which will have a length of at least 3, 
but could be very large) containing integers. 
The array is either entirely comprised of odd integers or 
entirely comprised of even integers except for a single integer N. 
Write a method that takes the array as an argument and returns this "outlier" N.
#+BEGIN_SRC 

Examples
[2, 4, 0, 100, 4, 11, 2602, 36]
Should return: 11 (the only odd number)

[160, 3, 1719, 19, 11, 13, -21]
Should return: 160 (the only even number)
#+END_SRC

** Solution

#+BEGIN_SRC C++
int FindOutlier(std::vector<int> arr)
{
    int even;
    int odd;
  
    int evenCount = 0;
    int oddCount = 0;
  
    for (auto a : arr)
        a % 2 == 0 ? (evenCount++, even = a) : (oddCount++, odd = a);
  
    return evenCount < oddCount ? even : odd;
}


#+END_SRC



* Cycle detection

** Extant
*** Floyd algorithm


*** Bernt's algorithm(The Teleporting Turtle)

** Experiment


* Factorial decomposition

** Description
The aim of the kata is to decompose n! (factorial n) into its prime factors.
#+BEGIN_SRC 
Examples:

n = 12; decomp(12) -> "2^10 * 3^5 * 5^2 * 7 * 11"
since 12! is divisible by 2 ten times, by 3 five times, by 5 two times and by 7 and 11 only once.

n = 22; decomp(22) -> "2^19 * 3^9 * 5^4 * 7^3 * 11^2 * 13 * 17 * 19"

n = 25; decomp(25) -> 2^22 * 3^10 * 5^6 * 7^3 * 11^2 * 13 * 17 * 19 * 23
Prime numbers should be in increasing order. When the exponent of a prime is 1 don't put the exponent.

#+END_SRC
*Notes*

- the function is decomp(n) and should return the decomposition of n! into 
  its prime factors in increasing order of the primes, as a string.
- factorial can be a very big number (4000! has 12674 digits, n will go from 300 to 4000).

** Solution
#+BEGIN_SRC c++
#include <string>
#include <map>
#include <sstream>

using std::vector;
using std::string;
using std::map;
string decomp(int n) {
  
  string ans("");
  std::stringstream ss;
  map<int, int> rc {};
  for(int i(2); i <= n; ++i) {
    
    int cur(i);
    for(auto &p : rc) {
      while(cur % p.first == 0) {
        cur /= p.first;
        p.second++;
      }
    }
    if(cur > 1) rc[cur] = 1;
  }
  for(auto p : rc) {
    
    (p.second == 1) ?
      ss << p.first : 
      ss << p.first << "^" << p.second;
    ss << " * ";
  }
  ans = ss.str();
  
  return ans.substr(0, ans.length() - 3);
}
#+END_SRC


* Counting Change Combinations

** Description
Write a function that counts how many different ways you can make change for an amount of money, given an array of coin denominations. For example, there are 3 ways to give change for 4 if you have coins with denomination 1 and 2:

1+1+1+1, 1+1+2, 2+2.

The order of coins does not matter:

1+1+2 == 2+1+1

Also, assume that you have an infinite amount of coins.

Your function should take an amount to change and an array of unique denominations for the coins:

#+BEGIN_SRC
  count_change(4, {1,2}) // => 3
  count_change(10, {5,2,3}) // => 4
  count_change(11, {5,7}) // => 0
#+END_SRC

** Solution

#+BEGIN_SRC c++

#include <vector>
#include <algorithm>

using std::vector;
unsigned long long 
dp(unsigned money, const vector<unsigned int>& coins) {

  unsigned long long ans(0);
  unsigned long long **rc = new unsigned long long*[money + 1];
  for (int i = 0; i < money+1; ++i) rc[i] = new unsigned long long[coins.size()];
  
  for(int i(0); i <= money; ++i)
    rc[i][coins.size()-1] = i % coins[coins.size()-1] == 0 ? 1 : 0;
  for(int j(0); j < coins.size(); ++j)
    rc[0][j] = 1;
  
  for(int i(1); i <= money; ++i)
    for(int j(coins.size()-2); j >= 0; --j) {
      
      if(i >= coins[j]) {
        rc[i][j] = rc[i - coins[j]][j]
                 + rc[i][j + 1];
      }
      else rc[i][j] = 0;
    }
  
  return rc[money][0];
}
//count m i = count (m-coins[i]) i + count m (i+1)
//count 0 _ = 1

unsigned long long 
countChange(const unsigned int money, const vector<unsigned int>& coins) {

  unsigned long long ans(0);
  
  vector<unsigned int> pac(coins);
  std::sort(pac.begin(), pac.end());

  ans = dp(money, pac);
  
  return ans;
}

#+END_SRC

#+BEGIN_SRC C++

unsigned long long 
countChange(unsigned money, const std::vector<unsigned>& coins) {
  std::vector<unsigned long long> ks(money + 1);
  ks[0] = 1;
  for (unsigned i : coins)
    for (unsigned j = i; j <= money; j++)
      ks[j] += ks[j - i];
  return ks[money];
}

#+END_SRC



* Longest Palindromic Substring

** Description
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example 1:
#+BEGIN_SRC
Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
#+END_SRC

Example 2:
#+BEGIN_SRC
Input: "cbbd"
Output: "bb"
#+END_SRC

** Solution
#+BEGIN_SRC c++

//DP method
string longestPalindrome(string s) {
  
  int rc[1000][1000], start(0), end(0), cur(0);
  for(int i(s.size()-1); i >= 0; --i) {
    for(int j(i); j < s.size(); ++j) {
      
      if(i == j) rc[i][j] = 1;
      else if(j - i == 1) rc[i][j] = s[i] == s[j] ? 2 : 0;
      else rc[i][j] = 
        rc[i+1][j-1] && s[i] == s[j] ? rc[i+1][j-1] + 2 : 0;
      cur = rc[i][j] > cur ?
        start = i, end = j, rc[i][j] : cur;
    }
  }
  return s.substr(start, end-start+1);
}

#+END_SRC





